% -*- noweb -*-
%\VignetteIndexEntry{rv}
%\VignettePackage{rv}
\documentclass[11pt,letterpaper]{article}
\pagestyle{myheadings}
\markright{\emph{rv} version 2.0.0}
\pagenumbering{arabic}

%\setlength{\textheight}{20 cm}

%\input{/Users/jkerman/lib/LaTeX/LaTeX-AMS-Commands}

\usepackage{Sweave}

\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\Umacs}{{Umacs}}
\usepackage{amsmath}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\newcommand{\rep}{\mathrm{rep}}
\newcommand{\D}{\mathrm{d}}
\newcommand{\inds}[1]{\mathrm{1}_{#1}}
\newcommand{\Normal}{\mathrm{Normal}}

\usepackage{natbib}
\bibliographystyle{plainnat}

\title{rv: a simulation-based random variable class\\
Version 2.0.0}

\author{Jouni Kerman}

 
\date{\today}
 
\begin{document}

\maketitle

\section{Introduction}

<<echo=FALSE>>=
  set.seed(20100129)
options(digits=2)
@ 

\emph{rv} is an implementation of a
simulation-based random variable object class for R,
originally introduced in 
\cite{Kerman:Gelman:2007}.

\emph{rv} implements a new class of vectors that
contain a `hidden dimension' of simulations in each scalar component. 
These \emph{rv objects} can be manipulated much like any numeric vectors,
but the arithmetic operations are performed on the simulations,
and summaries are calculated from the simulation vectors.

\emph{rv} is convenient for manipulating 
posterior simulations obtained from MCMC samplers,
for example using Umacs \citep{Kerman:2006:umacs} 
or R2WinBUGS \citep{Sturtz:2005:RPR}
(the package provides a coercion method to convert
\code{bugs} objects to \code{rv} objects.)

The paper by
\cite{Kerman:Gelman:2007}
introduces the principles
of the design of random variable objects. 
This document is a short overview of some of the 
commands provided by the package \code{rv}.
At the end of the document there is a short description
of the implementation.
%A short version of the paper is available as a vignette:
%\begin{verbatim}
 % vignette("rv-paper")
%\end{verbatim}


\subsection{Installation}

Install the package 'rv' (version 2.0.0 or higher)
using the Package Installer command in R (from the menu),
and load the package using,
<<echo=TRUE>>=
    library(rv)
@

\section{A quick tour}

The rv objects (or, ``random vectors") 
that we manipulate usually come from a Markov chain sampler.
To introduce some commands quickly, we will instead 
use some random vectors generated by 
\emph{random-vector generating functions}
which sample directly from a given (standard) distribution.

\paragraph{Number of simulations.}
First, we will set the number of simulations we use. 
We choose 4000 simulations per each scalar component
of a random vector:
<<>>=
rvnsims(4000)
@
We will not usually change this value during our 
session, unless we want to repeat our analysis with more (or fewer) simulations.
The default value is 4000, set whenever the package is loaded
for the first time in the workspace;
therefore this is not strictly a necessary step to do
every time we start the package. 

\paragraph{A Normally distributed random vector.}
To draw a random Gaussian (Normal) vector of length 5 with 
corresponding means $1,2,3,4,5$ and s.d. 1,
<<>>=
x <- rvnorm(mean=1:5, sd=1)
@ 
In effect, the object \code{x} now
contains five vectors of length $4000$,
drawn (internally) using \code{rnorm},
but we see \code{x} as a \emph{vector of length 5}.

The length of the vector is derived from the length of the 
mean vector (and the sd vector), and it is not necessary to
specify a parameter ``\code{n}". 

\paragraph{Quick distribution summary.}
To summarize the distribution of \code{x} by viewing quantiles,
means, and s.d.'s,  we only type the name of the object at the console:
<<>>=
  x
@ 

Similarly we can draw from Poisson
(\code{rvpois}) Gamma, (\code{rvgamma}),
Binomial (\code{rvbinom}):

<<>>=
  y <- rvpois(lambda=10)
@ 


\paragraph{Componentwise summaries.}
To extract the means, we use \code{rvmean}, 
the s.d.'s, we use \code{rvsd}, the minimum,
\code{rvmin}, the maximum \code{rvmax},
and the quantiles, we use \code{rvquantile}.
The componentwise medians are also obtained 
by \code{rvmedian}:
<<>>=
rvmean(x)
rvsd(x)
rvquantile(x, c(0.025,0.25,0.5,0.75,0.975))
rvmedian(x)
rvmin(y)
rvmax(y)
@ 



For convenience, there is an alias
\code{E(...)} for \code{rvmean(...)}
which gives the ``expectation" of a random vector.

\paragraph{Note.}
Since the random vectors are all represented
by simulations, the expectation and all other functions
that we compute are just numerical approximations.
Generating a ``standard normal random variable"
with \code{z <- rvnorm(n=1, mean=0, sd=1)}
will not have an expectation exactly zero.
Our main purpose here is to handle simulations,
so the answers will be approximate and 
necessarily involve a simulation error.

\paragraph{Extracting and replacing.}
Since rv objects work just like vectors,
we can extract and replace components by using the bracket
notation.
Here we replace the 3rd and 4th components
with random variables having (an approximate)
binomial distributions:
<<>>=
x[3:4] <- rvbinom(size=1, prob=c(0.1,0.9))
x[3:4]
@ 
The ``mean" column now shows the 
estimate of the expectation of 
the two indicator functions we generated.

\paragraph{Imputing into regular vectors.}
To ``impute" a random vector in a regular
numeric vector, we need first turn the constant 
vector into an \code{rv} object:
<<>>=
y <- as.rv(1:5)
y[3:4] <- x[3:4]
y
@ 
The non-random components appearing
as ``constants," or in other words,
random variables with point-mass distributions
(and therefore having a zero variance).

Ideally the coercing would happen automatically,
as \code{rv} vectors can be thought as being extensions
to ``regular'' vectors, but due to internal limitations
this is not possible to do in an appropriate and elegant fashion. 


\paragraph{Summaries of functions of random vectors.}
Standard numerical functions can be applied
directly to random vectors.
To find a summary of the distribution
of the function $1/(1+\exp(-x_1))$, we would write,
<<>>=
1/(1+exp(-x[1]))
@ 
Or of the function of almost anything we like:
<<>>=
2*log(abs(x[2]))
@ 


\paragraph{Order statistics.}
To simulate the order statistics of a random vector \code{x},
we can use \code{sort(x)}, \code{min(x)}, \code{max(x)}.
<<>>=
x <- rvpois(lambda=1:5)
x
sort(x)
min(x)
max(x)
@
Note: the \code{order} method is not implemented.





\paragraph{Random matrices and arrays.}

\emph{rv} objects behave like numerical vectors in R;
thus you can set their dimension attributes to make them appear as
arrays, and also use the matrix multiplication operator.
(Note: \code{\%**\%}
performs the matrix multiplication, ensuring that 
non-rv and \code{rv} objects get properly multiplied. 
Using \code{\%*\%} does not work if the  
matrix or vector on the left is not an rv object.)
<<>>=
p <- runif(4) # Some prior probabilities.
y <- rvbinom(size=1, prob=p) # y is now a rv of length 4.
dim(y) <- c(2,2) # Make y into a 2x2 matrix.
y
y %**% y
@ 
The componentwise summary functions
such as \code{E} (\code{rvmean}) and \code{rvsd} return the
summaries with the correct dimension attribute set:
<<>>=
E(y)
@ 

\paragraph{Creating indicator functions with logical operations.}
Applying logical operators gives indicators of events.
If \code{z} is a standard normal random variable
the indicator of the event $\{z>1\}$ is given by 
the statement \code{z>1}:
<<>>=
z <- rvnorm(1)
z > 1
@ 
We can also use the convenience function 
\code{Pr(...)} to compute the estimates 
of the expectation of these indicators:
<<>>=
Pr(z > 1)
@ 
Of course, we can find joint events as well
and computer their probabilities similarly.
To find the probability that $Z_1>Z_2^2$, where
both $Z_1$ and $Z_2$ are independent standard normal, we'd type
<<>>=
z <- rvnorm(2)
Pr(z[1] > z[2]^2)
@ 
We can even compute probabilities of intersections or unions of events,
<<>>=
Pr(x[1] > x[2] & x[1] > x[4])
Pr(x[1] > x[2] | x[1] > x[4])
@ 

\paragraph{Functions of several random variables.}
We can use random vectors, regular vectors, 
standard elementary functions, logical operations
in any combination as we wish.

Example.
Let $z_1,z_2$ be standard normal, and
let $y_1=\exp(z_1), y_2=y_1\exp(z_2)$.
Compute the expectation of $x=(y_1-1)\inds{y_1>1}\inds{y_2>1}$
and find the probability $\Pr(x>1)$.
<<>>=
z <- rvnorm(n=2, mean=0, sd=1)
y <- exp(z)
y[2] <- y[2] * y[1]
x <- (y[1]-1) * (y[1]>1) * (y[2]>1)
E(x)
Pr(x>1)
@ 

\paragraph{Posterior simulations from a classical regression model.}

We can generate posterior simulations
from a classical regression model,
using the standard assumptions for the priors.
For convenience there is a function \code{posterior} to do this.

<<>>=
  n <- 10
  ## Some covariates
  X <- data.frame(x1=rnorm(n, mean=0), x2=rpois(n, 10) - 10)
  y.mean <- (1.0 + 2.0 * X$x1 + 3.0 * X$x2)
  y <- rnorm(n, y.mean, sd=1.5) ## n random numbers
  D <- cbind(data.frame(y=y), X)
  ## Regression model fit
  fit <- lm(y ~ x1 + x2, data=D)
@ 
The Bayesian estimates (posterior distributions) are represented by,
<<>>=
  Post <- posterior(fit)
  Post
@ 

\paragraph{Creating replicated simulations.}


Continuing the previous example,
we'll resample from the sampling distribution of $y$
using the posterior simulations we got.
We can use the function \code{rvnorm} to do this,
since it accepts \emph{random vectors as arguments}.
Rather than think \code{rvnorm} to draw normal 
random vectors, it rather ``samples from the normal model."
The vector will be normal \emph{given} (constant) mean and s.d.,
but if the mean and s.d. are not constants, the resulting
vector will not be normal.
<<>>=
sigma <- Post$sigma
betas <- Post$beta
M <- model.matrix(fit)
y.rep <- rvnorm(mean=M %**% betas, sd=sigma)
mlplot(y.rep) # Summarize graphically.
@ 
Note also that \code{sigma} is also an rv object.

The matrix multiplication statement
returns a random vector of length 30:
<<>>=
M %**% betas
@ 
Thus all the uncertainty in the mean estimate $X\beta$
and the residual s.d. estimate $\sigma$ is propagated
when the replicated vector $y^\rep$ is generated.
In effect, this single line of code thus will in fact
draw from the distribution
$p({y}^\rep|y)=\int\int \Normal({y}^\rep|\mu,\sigma)p(\mu,\sigma|y)\D\mu\D\sigma.$

For convenience, there is a generic method
\code{rvpredict} to generate replications and predictions:

<<>>=
  ## Replications
  y.rep <- rvpredict(fit)
@ 

We can also generate predictions at some other covariate values:
<<>>=
  ## Predictions at the mean of the covariates
  X.pred <- data.frame(x1=mean(X$x1), x2=mean(X$x2))
  y.pred <- rvpredict(fit, newdata=X.pred)
@ 

We can also perturb (add uncertainty to) the covariate x1, then predict again.
<<>>=
  X.rep <- X
  X.rep$x1 <- rnorm(n=n, mean=X.rep$x1, sd=sd(X.rep$x1))
  y.pred2 <- rvpredict(fit, newdata=X.rep)
@ 



\paragraph{Graphical summaries}
Graphical summaries are still in development,
but it is now possible to plot
a scatterplot with a regular vector against a
random vector, showing the
50\% and 95\% \emph{uncertainty intervals}
along with the median, using
\code{plot(y,x,...)},
where \code{y} is not random but \code{x} is.
or we can show two random scalars plotted
as a 2-dimensional scatterplot with
\code{plot(x[1],x[2],...)}.

To illustrate, let us 
plot the predicted intervals of the previous example, 
along with the data points.

Plot
the predictions against \code{y} in red color;
then plot the perturbed predictions 
with blue color.

<<fig=TRUE>>=
  ## Plot predictions
  plot.rv(D$y, y.rep, rvcol="red")
  points.rv(D$y + 0.33, y.pred2, rvcol="blue")
@ 

Note that the function method needs to be called
explicitly to be able to plot constants vs. rv objects.
If the first argument of \code{plot(x, ...)} is an
rv object, one can call \code{plot}. 

Or, we can show a random vectors as
horizontal intervals using \code{mlplot}:
<<fig=TRUE>>=
  mlplot(y.rep, rvcol="red")
  mlplot(D$y, add=TRUE, col="blue", pch="x")
@

A histogram of the simulations of a random scalar \code{x[1]},
can be plotted with \code{rvhist}:
<<fig=TRUE>>=
rvhist(rvnorm(mean=0, sd=1)^3, xlim=c(-3, 3), col="red", main="Cubed standard normal")
@



\paragraph{Example: Simulating P\'olya's Urn.}
This code simulates 200 iterations of the
well-known P\'olya's urn problem.
The parameter \code{x/(n+1)} for the Bernoulli-variate-generating
function \code{rvbern(...)} is random:
we can generate random variables
using random parameters without much trickery;
our code looks therefore more natural.

The model:
\begin{eqnarray}
  \quad X_0 &= 1 \\
  \quad X_n-X_{n-1}|X_{n-1} &\sim \text{Bernoulli}( X_{n-1}/(n+1) )
\end{eqnarray}
{\large \\
The R code:
<<<>>=
  x <- 1
  for (n in 1:100) {
    x <- x + rvbern(n=1, prob=x / (n + 1))
  }
@ 
<<fig=TRUE>>=
  rvhist(x / (n + 1)) # Histogram
@ 
We can see that the distribution is close to uniform,
which is the limiting distribution in this case.


\section{Details}

\paragraph{Obtaining the simulation matrix.}
To extract the simulation matrix embedded in an rv object, use
\code{sims}:
<<>>=
s <- sims(y.rep)
dim(s)
@ 
It is our convention to have the columns represent the 
random vector and the rows represent the draws
from the joint distribution of the vector.

\paragraph{Converting matrices and vectors of simulations to rv objects.}
A matrix or a vector of simulations is converted into an rv object
by \code{rvsims}.
Continuing the above example, we'll convert the matrix back to
an rv object.
<<>>=
y <- rvsims(s)
@ 
You can verify that 
\code{all(sims(y)==s)}
returns 
\Sexpr{all(sims(y)==s)}. % TRUE
Also note that \code{dim(y)} gives 
\Sexpr{dim(y)},
since \code{y} is ``just a vector."

\paragraph{Coercing vectors and matrices.}
The function \code{as.rv(x)} coerces objects
to rv objects. However, this does not mean that 
matrices of simulations are turned into rv objects---this is
done with \code{rvsims}, as explained above.
\code{as.rv(rnorm(4000))} would return a random vector
of length 4000, where each component has zero variance
(and one single simulation). You probably 
mean \code{rvsims(rnorm(4000))}, but
the correct way to generate this object is
\code{rvnorm(1)}.

\paragraph{Obtaining simulations from R2WinBUGS}
R2WinBUGS \citep{Sturtz:2005:RPR} is an
interface for calling WinBUGS within R,
and obtaining the simulations as an R matrix
(that is embedded in a ``\code{bugs}" object).
If \code{bugsobj} is the bugs object returned by the
\code{bugs(...)} function call, then 
\code{as.rv} will coerce it into a list of random vectors,
split by the parameter names:
\code{y <- as.rv(bugsobj)}

\paragraph{Obtaining simulations from Umacs.}
Umacs facilitates the construction of a Gibbs/Metropolis
sampler in R \citep{Kerman:2006:umacs},
and returns the simulations wrapped in an ``\code{UmacsRun}"
object. Again, the coercion method \code{as.rv}
will convert the Umacs object, say \code{obj},
into a list of named random vectors:
\code{y <- as.rv(obj)}.


%\paragraph{cbind, rbind.}
%You need to use the commands \code{cbind.rv} and \code{rbind.rv}
%with rv objects. 
%The method dispatch does not work if the first object is not an rv.



%*** More documentation forthcoming ***


\section{Some implementation details}

\emph{rv} is written in ``S3" style object-oriented R
rather than using the \code{methods} (``S4") package.
The main reason was speed, the secondary consideration was
the ease of writing new functions. 

The main class is called ``rv".
Most functions expecting an rv object have
names starting with ``rv". for example
\code{rvnorm}, \code{rvmean}, etc.

The package also features rv-specific methods
extending the basic numeric vector classes,
e.g. \code{c.rv}, \code{plot.rv}, etc. 
However, the method-invoking routine is not perfect in R:
for example the concatenation function 
\code{c(...)} will not call \code{c.rv} 
for example
in the following case:
suppose that \code{x} is an object of class \code{rv}
and \code{k <- 10}.
Then \code{c(k, x)} will not call \code{c.rv}
since the method-dispatch mechanism only looks at the 
first element. 
To ensure the proper result, wrap the first element
in \code{as.rv}: 
\code{c(as.rv(k), x)} will produce a proper random vector.



\section{Disclaimer}

This program is a work in progress, and it may contain bugs. 
Many new features will be eventually (and hopefully) added. 

For information about random variables in R, 
please refer to \cite{Kerman:Gelman:2007}.
%For information about Umacs
%(Universal Markov chain sampler)
%please refer to \cite{Kerman:2006:umacs}.

%The web site \code{http://www.stat.columbia.edu/{\textasciitilde}kerman/} 
%contains links to the articles and to the software.


\addcontentsline{toc}{chapter}{Bibliography}

\begin{thebibliography}{3}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi: #1}\else
  \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi

\bibitem[Kerman(2006)]{Kerman:2006:umacs}
Jouni Kerman.
\newblock {U}macs: {A} {U}niversal {M}arkov {C}hain {S}ampler.
\newblock Technical report, Department of Statistics, Columbia University,
  2006.

\bibitem[Kerman and Gelman(2007)]{Kerman:Gelman:2007}
Jouni Kerman and Andrew Gelman.
\newblock Manipulating and summarizing posterior simulations using random
  variable objects.
\newblock \emph{Statistics and Computing} 17:3, 235--244.


\bibitem[Sturtz et~al.(2005)Sturtz, Ligges, and Gelman]{Sturtz:2005:RPR}
Sibylle Sturtz, Uwe Ligges, and Andrew Gelman.
\newblock {R2WinBUGS}: {A} package for running {WinBUGS} from {R}.
\newblock \emph{Journal of Statistical Software}, 12\penalty0 (3):\penalty0
  1--16, 2005.
\newblock ISSN 1548-7660.

\end{thebibliography}


\end{document}
