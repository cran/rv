% -*- noweb -*-
%\VignetteIndexEntry{rv}
%\VignettePackage{rv}
\documentclass[11pt,letterpaper]{article}
\pagestyle{myheadings}
\markright{\emph{rv} version 1.1.0}
\pagenumbering{arabic}

%\setlength{\textheight}{20 cm}

%\input{/Users/jkerman/lib/LaTeX/LaTeX-AMS-Commands}

\usepackage{Sweave}

\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\Umacs}{{Umacs}}
\usepackage{amsmath}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\newcommand{\rep}{\mathrm{rep}}
\newcommand{\D}{\mathrm{d}}
\newcommand{\inds}[1]{\mathrm{1}_{#1}}
\newcommand{\Normal}{\mathrm{Normal}}

\usepackage{natbib}
\bibliographystyle{plainnat}

\title{rv: a simulation-based random variable class\\
Version 1.1.0}

\author{Jouni Kerman}

 
\date{\today}
 
\begin{document}

\maketitle

\section{Introduction}

<<echo=FALSE>>=
  set.seed(20100129)
options(digits=2)
@ 

\emph{rv} is an implementation of a
simulation-based random variable object class for R,
originally introduced in 
\cite{Kerman:Gelman:2007}.
\emph{rv} implements a new class of vectors that
contain a hidden dimension of simulations in each scalar component. 
The rv objects can be manipulated much like any numeric vectors,
but the arithmetic operations are performed on the simulations,
and summaries are calculated from the simulation vectors.

\emph{rv} is convenient for manipulating 
posterior simulations obtained from MCMC samplers,
for example using Umacs \citep{Kerman:2006:umacs} 
or R2WinBUGS \citep{Sturtz:2005:RPR}
(the package provides a coercion method to convert
\code{bugs} objects to \code{rv} objects.)


The paper by
\cite{Kerman:Gelman:2007}
introduces the principles
of the design of random variable objects. 
This document is a short overview of some of the 
commands provided by the package \code{rv}.
At the end of the document there is a short description
of the implementation.
A short version of the paper is available as a vignette:
\begin{verbatim}
    vignette("rv-paper")
\end{verbatim}


\subsection{Installation}

Install the package 'rv' using the Package Installer command in R (from the menu). The version should be 0.920 or later,
and load the package using,
<<echo=FALSE>>=
    library(rv)
@

\section{A quick tour}

The rv objects (or, ``random vectors") 
that we manipulate usually come from a Markov chain sampler.
To introduce some commands quickly, we will instead 
use some random vectors generated by 
\emph{random-vector generating functions}
which sample from a given distribution.

\paragraph{Number of simulations.}
First, we will set the number of simulations we use. 
We choose 2500 simulations per each scalar component
of a random vector:
<<>>=
rvnsims(2500)
@ 
We will not usually change this value during our 
session, unless we want to repeat our analysis with more (or fewer) simulations.
2500 is also the default value so this is not a necessary step to do
every time we start the package.

\paragraph{A Normally distributed random vector.}
To draw a random Gaussian (Normal) vector of length 5 with 
corresponding means $1,2,3,4,5$ and s.d. 1,
<<>>=
x <- rvnorm(mean=1:5, sd=1)
@ 
In effect, the object \code{x} now
contains five vectors of length 1000,
drawn (internally) using \code{rnorm},
but we see \code{x} as a \emph{vector of length 5}.

The length of the vector is derived from the length of the 
mean vector (and the sd vector), and it is not necessary to
specify a parameter ``\code{n}". 

\paragraph{Quick distribution summary.}
To summarize the distribution of \code{x} by viewing quantiles,
means, and s.d.'s,  we only type the name of the object at the console:
<<>>=
  x
@ 

Similarly we can draw from Poisson
(\code{rvpois}) Gamma, (\code{rvgamma}),
Binomial (\code{rvbinom}).


\paragraph{Componentwise summaries.}
To extract the means, we use \code{rvmean}, 
the s.d.'s, we use \code{rvsd}, the minimum,
\code{rvmin}, the maximum \code{rvmax},
and the quantiles, we use \code{rvquantile}.
The componentwise medians are also obtained 
by \code{rvmedian}:
<<>>=
rvmin(x)
rvmean(x)
rvsd(x)
rvmin(x)
rvquantile(x, c(0.025,0.25,0.5,0.75,0.975))
rvmax(x)
rvmedian(x)
@ 


For convenience, there is an alias
\code{E(...)} for \code{rvmean(...)}
which gives the ``expectation" of a random vector.

\paragraph{Note.}
Since the random vectors are all represented
by simulations, the expectation and all other functions
that we compute are just numerical approximations.
Generating a ``standard normal random variable"
with \code{z <- rvnorm(n=1, mean=0, sd=1)}
will not have an expectation exactly zero.
Our main purpose here is to handle simulations,
so the answers will be approximate and 
necessarily involve a simulation error.

\paragraph{Extracting and replacing.}
Since rv objects work just like vectors,
we can extract and replace components by using the bracket
notation.
Here we replace the 3rd and 4th components
with random variables having (an approximate)
binomial distributions:
<<>>=
x[3:4] <- rvbinom(size=1, prob=c(0.1,0.9))
x[3:4]
@ 
The ``mean" column now shows the 
estimate of the expectation of 
the two indicator functions we generated.

\paragraph{Imputing into regular vectors.}
It is possible to ``impute" a random vector in a regular
numeric vector:
<<>>=
y <- 1:5
y[3:4] <- x[3:4]
y
@ 
The regular numeric vector is coerced into an rv 
object with the non-random components appearing
as ``constants," or in other words,
random variables with point-mass distributions
(and therefore having a zero variance).


\paragraph{Summaries of functions of random vectors.}
Standard numerical functions can be applied
directly to random vectors.
To find a summary of the distribution
of the function $1/(1+\exp(-x_1))$, we would write,
<<>>=
1/(1+exp(-x[1]))
@ 
Or of the function of almost anything we like:
<<>>=
2*log(abs(x[2]))
@ 


\paragraph{Order statistics.}
To simulate the order statistics of a random vector \code{x},
we can use \code{sort(x)}, \code{min(x)}, \code{max(x)}.
<<>>=
x <- rvpois(lambda=1:5)
x
sort(x)
min(x)
max(x)
@
Note: the \code{order} method is not implemented.





\paragraph{Random matrices and arrays.}

\emph{rv} objects behave like numerical vectors in R;
thus you can set their dimension attributes to make them appear as
arrays, and also use the matrix multiplication operator.
<<>>=
p <- runif(4) # Some prior probabilities.
y <- rvbinom(size=1, prob=p) # y is now a rv of length 4.
dim(y) <- c(2,2) # Make y into a 2x2 matrix.
y
y %*% y
@ 
The componentwise summary functions
such as \code{E} (\code{rvmean}) and \code{rvsd} return the
summaries with the correct dimension attribute set:
<<>>=
E(y)
@ 

\paragraph{Creating indicator functions with logical operations.}
Applying logical operators gives indicators of events.
If \code{z} is a standard normal random variable
the indicator of the event $\{z>1\}$ is given by 
the statement \code{z>1}:
<<>>=
z <- rvnorm(1)
z > 1
@ 
We can also use the convenience function 
\code{Pr(...)} to compute the estimates 
of the expectation of these indicators:
<<>>=
Pr(z > 1)
@ 
Of course, we can find joint events as well
and computer their probabilities similarly.
To find the probability that $Z_1>Z_2^2$, where
both $Z_1$ and $Z_2$ are independent standard normal, we'd type
<<>>=
z <- rvnorm(2)
Pr(z[1] > z[2]^2)
@ 
We can even compute probabilities of intersections or unions of events,
<<>>=
Pr(x[1] > x[2] & x[1] > x[4])
Pr(x[1] > x[2] | x[1] > x[4])
@ 

\paragraph{Functions of several random variables.}
We can use random vectors, regular vectors, 
standard elementary functions, logical operations
in any combination as we wish.

Example.
Let $z_1,z_2$ be standard normal, and
let $y_1=\exp(z_1), y_2=y_1\exp(z_2)$.
Compute the expectation of $x=(y_1-1)\inds{y_1>1}\inds{y_2>1}$
and find the probability $\Pr(x>1)$.
<<>>=
z <- rvnorm(n=2, mean=0, sd=1)
y <- exp(z)
y[2] <- y[2] * y[1]
x <- (y[1]-1) * (y[1]>1) * (y[2]>1)
E(x)
Pr(x>1)
@ 

\paragraph{Graphical summaries}
Graphical summaries are still in development,
but it is now possible to plot
a scatterplot with a regular vector against a
random vector, showing the
50\% and 95\% \emph{uncertainty intervals}
along with the median, using
\code{plot(y,x,...)},
where \code{y} is not random but \code{x} is.
or we can show two random scalars plotted
as a 2-dimensional scatterplot with
\code{plot(x[1],x[2],...)}.

Or, we can show a random vectors as
horizontal intervals using \code{mlplot}:
<<fig=TRUE>>=
mlplot(x)
@

The histogram of the simulations of a random scalar \code{x[1]}
can be plotted with
<<fig=TRUE>>=
rvhist(x[1])
@ 

\paragraph{Posterior simulations from a classical regression model.}

We can generate posterior simulations
from a classical regression model,
using the standard assumptions for the priors.
For convenience there is a function \code{postsim} to do this.
<<>>=
x <- 1:30
y <- rnorm(30, mean=x/10) # Some fake data.
fit <- lm(y ~ x)
s  <- postsim(fit)
@ 
Now \code{s["sigma"]} contains the variable
$\sigma$ with simulations from
the posterior distribution $p(\sigma|y)$:
<<>>=
 s["sigma"]
@ 
and the other components are the coefficient estimates $\beta$
with the joint distribution $p(\beta|y)$.

\paragraph{Creating replicated simulations.}
Continuing the previous example,
we'll resample from the sampling distribution of $y$
using the posterior simulations we got.
We can use the function \code{rvnorm} to do this,
since it accepts \emph{random vectors as arguments}.
Rather than think \code{rvnorm} to draw normal 
random vectors, it rather ``samples from the normal model."
The vector will be normal \emph{given} (constant) mean and s.d.,
but if the mean and s.d. are not constants, the resulting
vector will not be normal.
<<>>=
sigma <- s[1]
betas <- s[-1]
X <- model.matrix(fit)
y.rep <- rvnorm(mean=X %*% betas, sd=sigma)
mlplot(y.rep) # Summarize graphically.
@ 
The function call
<<>>=
X %*% betas
@ 
returns a random vector of length 30, and \code{sigma}
is also random. 
Thus all the uncertainty in the mean estimate $X\beta$
and the residual s.d. estimate $\sigma$ is propagated
when the replicated vector $y^\rep$ is generated.
In effect, this single line of code thus will in fact
draw from the distribution
$p({y}^\rep|y)=\int\int \Normal({y}^\rep|\mu,\sigma)p(\mu,\sigma|y)\D\mu\D\sigma.$


\paragraph{Example: Simulating P\'olya's Urn.}
This code simulates 200 iterations of the
well-known P\'olya's urn problem.
The parameter \code{x/(n+1)} for the Bernoulli-variate-generating
function \code{rvbern(...)} is random:
we can generate random variables
using random parameters without much trickery;
our code looks therefore more natural.

The model:
\begin{eqnarray}
  \quad X_0 &= 1 \\
  \quad X_n-X_{n-1}|X_{n-1} &\sim \text{Bernoulli}( X_{n-1}/(n+1) )
\end{eqnarray}
{\large \\
The R code:
<<<>>=
  x <- 1
  for (n in 1:100) {
    x <- x + rvbern(n=1, prob=x / (n + 1))
  }
@ 
<<fig=TRUE>>=
  rvhist(x / (n + 1)) # Histogram
@ 
We can see that the distribution is close to uniform,
which is the limiting distribution in this case.


\section{Details}

\paragraph{Obtaining the simulation matrix.}
To extract the simulation matrix embedded in an rv object, use
\code{sims}:
<<>>=
s <- sims(y.rep)
dim(s)
@ 
It is our convention to have the columns represent the 
random vector and the rows represent the draws
from the joint distribution of the vector.

\paragraph{Converting matrices and vectors of simulations to rv objects.}
A matrix or a vector of simulations is converted into an rv object
by \code{rvsims}.
Continuing the above example, we'll convert the matrix back to
an rv object.
<<>>=
y <- rvsims(s)
@ 
You can verify that 
\code{all(sims(y)==s)}
returns 
\Sexpr{all(sims(y)==s)}. % TRUE
Also note that \code{dim(y)} gives 
\Sexpr{dim(y)},
since \code{y} is ``just a vector."

\paragraph{Coercing vectors and matrices.}
The function \code{as.rv(x)} coerces objects
to rv objects. However, this does not mean that 
matrices of simulations are turned into rv objects---this is
done with \code{rvsims}, as explained above.
\code{as.rv(rnorm(1000))} would return a random vector
of length 1000, where each component has zero variance
(and one single simulation). You probably 
mean \code{rvsims(rnorm(1000))}, but
the correct way to generate this object is
\code{rvnorm(1)}.

\paragraph{Obtaining simulations from R2WinBUGS}
R2WinBUGS \citep{Sturtz:2005:RPR} is an
interface for calling WinBUGS within R,
and obtaining the simulations as an R matrix
(that is embedded in a ``\code{bugs}" object).
If \code{bugsobj} is the bugs object returned by the
\code{bugs(...)} function call, then 
\code{as.rv} will coerce it into a random vector:
\code{y <- as.rv(bugsobj)}
Now \code{y} is a vector with the \code{names} attribute set.
Usually we want to access the components 
such as \code{theta[1],...,theta[8]} and 
\code{sigma} etc. by their names, directly.
You can split a random vector into a
list of named subvectors by 
\code{splitbyname}:
<<>>=
 x <- rvnorm(6)
 names(x) <- c(paste("theta[", 1:4, "]", sep=""), paste("mu[", 1:2, "]", sep=""))
 x
 rv::splitbyname(x)
@ 

\paragraph{Obtaining simulations from Umacs.}
Umacs facilitates the construction of a Gibbs/Metropolis
sampler in R \citep{Kerman:2006:umacs},
and returns the simulations wrapped in an ``\code{UmacsRun}"
object. Again, the coercion method \code{as.rv}
will convert the Umacs object, say \code{obj},
into a list of namedsubvectors:
\code{y <- as.rv(obj)}.


%\paragraph{cbind, rbind.}
%You need to use the commands \code{cbind.rv} and \code{rbind.rv}
%with rv objects. 
%The method dispatch does not work if the first object is not an rv.



%*** More documentation forthcoming ***


\section{Some implementation details}

\emph{rv} is written in ``S3" style object-oriented R
rather than using the \code{methods} (``S4") package.
The main reason was speed, the secondary consideration was
the ease of writing new functions. 

The main class is called ``rv".
Most functions expecting an rv object have
names starting with ``rv". for example
\code{rvnorm}, \code{rvmean}, etc.

The package also features rv-specific methods
extending the basic numeric vector classes,
e.g. \code{c.rv}, \code{plot.rv}, etc. 
However, the method-invoking routine is not perfect in R:
for example the concatenation function 
\code{c(...)} will not call \code{c.rv} 
for example
in the following case:
suppose that \code{x} is an object of class \code{rv}.
Then \code{c(10, x)} will not call \code{c.rv}
since the method-dispatch mechanism only looks at the 
first element. 
%Functions like \code{cov},
%\code{var} are not even written to be object-oriented.
As a temporary measure, 
the current version of 
\emph{rv} overwrites some of the functions in the base classes
to create the illusion of proper method-dispatch mechanism.
(Ideally, the simulation dimension should be part of 
R itself.)
To temporarily disable the overwritten basic functions,
execute \code{rvcompatibility(1)}.




\section{Disclaimer}

This program is a work in progress, and it may contain bugs. 
Many new features will be eventually (and hopefully) added. 

For information about random variables in R, 
please refer to \cite{Kerman:Gelman:2007}.
%For information about Umacs
%(Universal Markov chain sampler)
%please refer to \cite{Kerman:2006:umacs}.

The web site \code{http://www.stat.columbia.edu/{\textasciitilde}kerman/} 
contains links to the articles and to the software.


\addcontentsline{toc}{chapter}{Bibliography}

\begin{thebibliography}{4}
\providecommand{\natexlab}[1]{#1}
\providecommand{\url}[1]{\texttt{#1}}
\expandafter\ifx\csname urlstyle\endcsname\relax
  \providecommand{\doi}[1]{doi: #1}\else
  \providecommand{\doi}{doi: \begingroup \urlstyle{rm}\Url}\fi

\bibitem[Kerman(2005)]{Kerman:2005:rvapps}
Jouni Kerman.
\newblock Using random variable objects to compute probability simulations.
\newblock Technical report, Department of Statistics, Columbia University,
  2005.

\bibitem[Kerman(2006)]{Kerman:2006:umacs}
Jouni Kerman.
\newblock {U}macs: {A} {U}niversal {M}arkov {C}hain {S}ampler.
\newblock Technical report, Department of Statistics, Columbia University,
  2006.

\bibitem[Kerman and Gelman(2007)]{Kerman:Gelman:2007}
Jouni Kerman and Andrew Gelman.
\newblock Manipulating and summarizing posterior simulations using random
  variable objects.
\newblock \emph{Statistics and Computing} 17:3, 235--244.


\bibitem[Sturtz et~al.(2005)Sturtz, Ligges, and Gelman]{Sturtz:2005:RPR}
Sibylle Sturtz, Uwe Ligges, and Andrew Gelman.
\newblock {R2WinBUGS}: {A} package for running {WinBUGS} from {R}.
\newblock \emph{Journal of Statistical Software}, 12\penalty0 (3):\penalty0
  1--16, 2005.
\newblock ISSN 1548-7660.

\end{thebibliography}


\end{document}
